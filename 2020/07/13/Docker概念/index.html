<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl"/>
  
  
  
  
  <title>Docker概念 | 落墨</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Docker 是世界领先的软件容器平台。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker概念">
<meta property="og:url" content="https://keysluomo.github.io/2020/07/13/Docker%E6%A6%82%E5%BF%B5/index.html">
<meta property="og:site_name" content="落墨">
<meta property="og:description" content="Docker 是世界领先的软件容器平台。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://keysluomo.github.io/2020/07/13/Docker%E6%A6%82%E5%BF%B5/1.png">
<meta property="og:image" content="https://keysluomo.github.io/2020/07/13/Docker%E6%A6%82%E5%BF%B5/2.png">
<meta property="og:image" content="https://keysluomo.github.io/2020/07/13/Docker%E6%A6%82%E5%BF%B5/3.png">
<meta property="og:image" content="https://keysluomo.github.io/2020/07/13/Docker%E6%A6%82%E5%BF%B5/4.png">
<meta property="og:image" content="https://keysluomo.github.io/2020/07/13/Docker%E6%A6%82%E5%BF%B5/5.png">
<meta property="og:image" content="https://keysluomo.github.io/2020/07/13/Docker%E6%A6%82%E5%BF%B5/6.png">
<meta property="og:image" content="https://keysluomo.github.io/2020/07/13/Docker%E6%A6%82%E5%BF%B5/7.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2019/11/dockerfile2.png">
<meta property="article:published_time" content="2020-07-13T13:44:31.000Z">
<meta property="article:modified_time" content="2020-07-18T03:52:26.509Z">
<meta property="article:author" content="落墨">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://keysluomo.github.io/2020/07/13/Docker%E6%A6%82%E5%BF%B5/1.png">
  
    <link rel="alternative" href="/atom.xml" title="落墨" type="application/atom+xml">
  
  
  
  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
<meta name="generator" content="Hexo 4.2.1"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/avatar.png" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">落墨</a></h1>
        </hgroup>
        
        <p class="header-subtitle">凡心所向，素履以往</p>
        
        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/archives/">所有文章</a></li>
                        
                            <li><a  href="/categories/Flink/">Flink</a></li>
                        
                            <li><a  href="/categories/Spark/">Spark</a></li>
                        
                            <li><a  href="/categories/Java/">Java</a></li>
                        
                            <li><a  href="/categories/JVM">JVM</a></li>
                        
                            <li><a  href="/categories/Scala/">Scala</a></li>
                        
                            <li><a  href="/categories/Kafka">Kafka</a></li>
                        
                            <li><a  href="/categories/Hadoop">Hadoop生态圈</a></li>
                        
                            <li><a  href="/categories/Zookeeper">Zookeeper</a></li>
                        
                            <li><a  href="/categories/Zeppelin">Zeppelin</a></li>
                        
                            <li><a  href="/categories/Tools">Tools</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="/xxxxx" title="github">github</a>
                            
                                <a class="fl weibo"  target="_blank" href="/xxxxxxxx" title="weibo">weibo</a>
                            
                                <a class="fl rss"  target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/DataStream-API/" style="font-size: 10px;">DataStream API</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Eagle/" style="font-size: 10px;">Eagle</a> <a href="/tags/Error/" style="font-size: 10px;">Error</a> <a href="/tags/Flink/" style="font-size: 20px;">Flink</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/Hadoop%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">Hadoop部署</a> <a href="/tags/Hive/" style="font-size: 10px;">Hive</a> <a href="/tags/Hive%E6%A6%82%E8%BF%B0/" style="font-size: 10px;">Hive概述</a> <a href="/tags/Hive%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">Hive索引</a> <a href="/tags/JVM/" style="font-size: 20px;">JVM</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/Serializable/" style="font-size: 10px;">Serializable</a> <a href="/tags/Spark/" style="font-size: 10px;">Spark</a> <a href="/tags/SpringBoot/" style="font-size: 10px;">SpringBoot</a> <a href="/tags/Table-API-SQL/" style="font-size: 10px;">Table API & SQL</a> <a href="/tags/VMware/" style="font-size: 10px;">VMware</a> <a href="/tags/Zeppelin-%E5%AE%89%E8%A3%85/" style="font-size: 10px;">Zeppelin 安装</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/" style="font-size: 10px;">分布式文件存储</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" style="font-size: 10px;">垃圾收集器</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/" style="font-size: 10px;">垃圾收集算法</a> <a href="/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/" style="font-size: 10px;">性能调优</a> <a href="/tags/%E6%AD%BB%E9%94%81/" style="font-size: 10px;">死锁</a> <a href="/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">版本控制工具</a> <a href="/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%8E%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6/" style="font-size: 10px;">状态管理与容错机制</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">编程语言</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 15px;">转载</a> <a href="/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/" style="font-size: 10px;">运行时数据区域</a> <a href="/tags/%E9%9B%86%E7%BE%A4%E7%9B%91%E6%8E%A7/" style="font-size: 10px;">集群监控</a> <a href="/tags/%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">集群部署</a> <a href="/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D/" style="font-size: 10px;">零拷贝</a>
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.csdn.net/baidu_21483933">csdn</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://segmentfault.com/blog/maocg_web">segmentfault</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.jianshu.com/users/eb37ef89c746/latest_articles">简书</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">本人性格开朗、有活力，待人热情，能迅速的适应各种环境。 热衷于新技术学习和实践，乐于寻求挑战和突破自我。</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">落墨</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/avatar.png" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">落墨</a></h1>
            </hgroup>
            
            <p class="header-subtitle">凡心所向，素履以往</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/categories/Flink/">Flink</a></li>
                
                    <li><a href="/categories/Spark/">Spark</a></li>
                
                    <li><a href="/categories/Java/">Java</a></li>
                
                    <li><a href="/categories/JVM">JVM</a></li>
                
                    <li><a href="/categories/Scala/">Scala</a></li>
                
                    <li><a href="/categories/Kafka">Kafka</a></li>
                
                    <li><a href="/categories/Hadoop">Hadoop生态圈</a></li>
                
                    <li><a href="/categories/Zookeeper">Zookeeper</a></li>
                
                    <li><a href="/categories/Zeppelin">Zeppelin</a></li>
                
                    <li><a href="/categories/Tools">Tools</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="/xxxxx" title="github">github</a>
                    
                        <a class="weibo" target="_blank" href="/xxxxxxxx" title="weibo">weibo</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap"><article id="post-Docker概念" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2020/07/13/Docker%E6%A6%82%E5%BF%B5/" class="article-date">
      <time datetime="2020-07-13T13:44:31.000Z" itemprop="datePublished">2020-07-13</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Docker概念
    </h1>
  


      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Other/">Other</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为什么会有Docker的出现呢？可能很多不了解的人都会有这样的疑问。最近工作中有接触到Docker所以就有了这篇文章。</p>
<p>Docker 是世界领先的软件容器平台。<br>开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。<br>运维人员利用 Docker 可以在隔离容器中并行运行和管理应用，获得更好的计算密度。<br>企业利用 Docker 可以构建敏捷的软件交付管道，以更快的速度、更高的安全性和可靠的信誉为 Linux 和 Windows Server 应用发布新功能。</p>
<h1 id="为什么需要Docker？"><a href="#为什么需要Docker？" class="headerlink" title="为什么需要Docker？"></a>为什么需要Docker？</h1><h2 id="1-环境（切换-配置）麻烦"><a href="#1-环境（切换-配置）麻烦" class="headerlink" title="1.环境（切换/配置）麻烦"></a>1.环境（切换/配置）麻烦</h2><p>一般我们写程序，能接触到好几个环境：</p>
<ul>
<li>自己写代码的环境叫做开发环境</li>
<li>给测试去跑的环境叫做测试环境</li>
<li>测试完可以对外使用的叫做生产环境</li>
</ul>
<p>其实我们在学习编程中，很多时间都浪费在“环境”上：</p>
<ul>
<li>如果我现在重装了系统，我想要跑我的<code>war/jar</code>包，我得去安装一下JDK、Tomcat、MySQL等配置各种的环境变量才能跑起来。</li>
<li>开开心心地跟着博主给出的步骤去写Demo，但总是有Bug。(这里我将<strong>版本/依赖</strong>也归纳在环境的范畴里边)。</li>
<li>好不容易在测试环境下跑起来了，在生产环境就各种出错！</li>
<li>跟着教学视频做分布式/集群的项目，跑一堆的虚拟机，每个虚拟机都要安装对应的环境。</li>
</ul>
<h2 id="2-应用之间需要隔离"><a href="#2-应用之间需要隔离" class="headerlink" title="2.应用之间需要隔离"></a>2.应用之间需要隔离</h2><p>比如我写了两个应用(网站)，这两个应用部署在同一台服务器上，那可能会出现什么问题？</p>
<ul>
<li>如果一个应用出现了问题，导致CPU占100%。那另一个应用也会受到关联，跟着一起凉凉了。</li>
<li>这两个应用是完全不同技术栈的应用，比如一个<code>PHP</code>，一个<code>.NET</code>。这两个应用<strong>各种的依赖软件</strong>都安装在同一个服务器上，可能就会造成<strong>各种冲突/无法兼容</strong>，这可能调试就非常麻烦了。</li>
</ul>
<h2 id="Docker是如何解决上述的问题"><a href="#Docker是如何解决上述的问题" class="headerlink" title="Docker是如何解决上述的问题"></a>Docker是如何解决上述的问题</h2><h2 id="1-解决环境-切换-配置"><a href="#1-解决环境-切换-配置" class="headerlink" title="1.解决环境(切换/配置)"></a>1.解决环境(切换/配置)</h2><p>不知道大家有没有装过系统，比如说装Linux虚拟机，重装Windows系统，都是需要<strong>镜像</strong>的。</p>
<p><img src="/2020/07/13/Docker%E6%A6%82%E5%BF%B5/1.png" alt></p>
<p>有了这个镜像，我们就可以<strong>运行</strong>这个镜像，来进行安装系统的操作(此处省略N个下一步)，于是我们的系统就装好了。一般来说，我们去官方渠道下载的镜像，都是<strong>纯净</strong>的。比如去官方下载Windows镜像，装完后之后桌面只有一个回收站。</p>
<p>但有过了解装系统的同学可能就会知道，有的镜像装完可能还有360这些软件，但系统的的确确是<strong>变了</strong>。简单来说，就是这些镜像<strong>添加</strong>了其他的东西(比如360软件、腾讯、千千静听等等软件)。</p>
<p>Docker也是这种思路，可以将我们的想要的环境<strong>构建</strong>(打包)成一个镜像，然后我们可以<strong>推送</strong>(发布)到网上去。想要用这个环 境的时候，在网上<strong>拉取</strong>一份就好了。</p>
<p>有了Docker，我们在搭环境的时候，跟以前的方式就不一样了。</p>
<ul>
<li><strong>之前</strong>：在开发环境构建出了一个war包，想跑到Linux下运行。我们得先在Linux下载好Java、Tomcat、MySQL，配置好对应的环境变量，将war包丢到Tomcat的webapps文件夹下，才能跑起来。</li>
<li><strong>现在</strong>：在Linux下直接拉取一份镜像(各种环境都配好了)，将镜像运行起来，把war包丢进去就好了。</li>
</ul>
<p>将Docker的镜像运行起来就是一两秒的事情而已，十分方便的。</p>
<h2 id="2-解决应用之间隔离"><a href="#2-解决应用之间隔离" class="headerlink" title="2.解决应用之间隔离"></a>2.解决应用之间隔离</h2><p>说到这里，就得提出一个大家可能不认识的概念：LXC(Linux Containers)—&gt;Linux容器。</p>
<p><strong>Linux</strong></p>
<blockquote>
<p>在Linux内核中，提供了<strong>cgroups</strong>功能，来达成资源的区隔化。它同时也提供了名称空间(<strong>namespace</strong>)区隔化的功能，<strong>使应用程序看到的操作系统环境被区隔成独立区间</strong>，包括进程树，网络，用户id，以及挂载的文件系统。</p>
</blockquote>
<p>简单来说就是：LXC是一个为Linux内核包含特征的<strong>用户接口</strong>。通过强大的API和简单的工具，它可以让Linux用户轻松的创建和托管系统或者应用程序容器。</p>
<h1 id="虚拟机和Docker"><a href="#虚拟机和Docker" class="headerlink" title="虚拟机和Docker"></a>虚拟机和Docker</h1><p>我之前也是用过虚拟机，虚拟机也能实现对应用的隔离，安装特定的镜像也能抛出我们想要的环境。虚拟机已经发展了很久了。为什么我们还需要Docker呢？</p>
<h2 id="虚拟机和Docker的区别"><a href="#虚拟机和Docker的区别" class="headerlink" title="虚拟机和Docker的区别"></a>虚拟机和Docker的区别</h2><p><img src="/2020/07/13/Docker%E6%A6%82%E5%BF%B5/2.png" alt></p>
<p>一句话总结：Docker容器比虚拟机<strong>轻量</strong>多了！</p>
<p>Docker可以干嘛？</p>
<ul>
<li>将一整套环境打包封装成镜像，<strong>无需重复配置环境</strong>，解决环境带来的种种问题。</li>
<li>Docker容器间是进程隔离的，谁也不会影响谁。</li>
</ul>
<h1 id="Docker-基本命令"><a href="#Docker-基本命令" class="headerlink" title="Docker 基本命令"></a>Docker 基本命令</h1><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p>Docker 允许你在容器内运行应用程序， 使用 docker run 命令来在一个容器内运行一个应用程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu:15.10 &#x2F;bin&#x2F;echo &quot;Hello world&quot;</span><br></pre></td></tr></table></figure>
<p>各个参数解析：</p>
<ul>
<li>docker：Docker的二进制执行文件。</li>
<li>run: 与前面的 docker 组合来运行一个容器。</li>
<li>ubuntu:15.10 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li>
<li>/bin/echo “Hello world”: 在启动的容器里执行的命令</li>
</ul>
<h2 id="运行交互式的容器"><a href="#运行交互式的容器" class="headerlink" title="运行交互式的容器"></a>运行交互式的容器</h2><p>我们通过 docker 的两个参数 -i -t，让 docker 运行的容器实现<strong>“对话”</strong>的能力：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t ubuntu:15.10 &#x2F;bin&#x2F;bash</span><br><span class="line">root@0123ce188bd8:&#x2F;#</span><br></pre></td></tr></table></figure>
<p>各个参数解析：</p>
<ul>
<li>-t：在新容器内指定一个伪终端。</li>
<li><strong>-i:</strong> 允许你对容器内的标准输入 (STDIN) 进行交互。</li>
</ul>
<p>注意第二行 <strong>root@0123ce188bd8:/#</strong>，此时我们已进入一个 ubuntu15.10 系统的容器</p>
<p>我们尝试在容器中运行命令 <strong>cat /proc/version</strong>和<strong>ls</strong>分别查看当前系统的版本信息和当前目录下的文件列表</p>
<p>我们可以通过运行 exit 命令或者使用 CTRL+D 来退出容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@0123ce188bd8:&#x2F;#  exit</span><br><span class="line">exit</span><br><span class="line">root@runoob:~#</span><br></pre></td></tr></table></figure>
<h2 id="启动容器后台模式"><a href="#启动容器后台模式" class="headerlink" title="启动容器后台模式"></a>启动容器后台模式</h2><p>使用一下命令创建一个以进程方式运行的容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -d ubuntu:15.10 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line">2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63</span><br></pre></td></tr></table></figure>
<p>在输出中，我们没有看到期望的 “hello world”，而是一串长字符</p>
<p><strong>2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63</strong></p>
<p>这个长字符串叫做容器 ID，对每个容器来说都是唯一的，我们可以通过容器 ID 来查看对应的容器发生了什么。</p>
<p>首先，我们需要确认容器有在运行，可以通过 <strong>docker ps</strong> 来查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                  COMMAND              ...  </span><br><span class="line">5917eac21c36        ubuntu:15.10           &quot;&#x2F;bin&#x2F;sh -c &#39;while t…&quot;    ...</span><br></pre></td></tr></table></figure>
<p>输出详情介绍：</p>
<p><strong>CONTAINER ID:</strong> 容器 ID。</p>
<p><strong>IMAGE:</strong> 使用的镜像。</p>
<p><strong>COMMAND:</strong> 启动容器时运行的命令。</p>
<p><strong>CREATED:</strong> 容器的创建时间。</p>
<p><strong>STATUS:</strong> 容器状态。</p>
<p>状态有7种：</p>
<ul>
<li>created（已创建）</li>
<li>restarting（重启中）</li>
<li>running（运行中）</li>
<li>removing（迁移中）</li>
<li>paused（暂停）</li>
<li>exited（停止）</li>
<li>dead（死亡）</li>
</ul>
<p><strong>PORTS:</strong> 容器的端口信息和使用的连接类型（tcp\udp）。</p>
<p><strong>NAMES:</strong> 自动分配的容器名称。</p>
<p>在宿主主机内使用 <strong>docker logs</strong> 命令，查看容器内的标准输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker logs 2b1b7a428627</span><br></pre></td></tr></table></figure>
<h2 id="Docker容器使用"><a href="#Docker容器使用" class="headerlink" title="Docker容器使用"></a>Docker容器使用</h2><ul>
<li>Docker:我们可以直接输入docker命令查看到Docker客户端的所有命令选项</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~# docker</span><br></pre></td></tr></table></figure>
<ul>
<li>docker stats –help 更深入的了解指定的Docker命令使用方法   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~# docker stats --help</span><br></pre></td></tr></table></figure>
<ul>
<li>docker pull ubuntu：我们可以使用docker pull 命令来载入ubuntu镜像</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure>
<ul>
<li>启动容器，以下命令使用ubuntu镜像启动一个容器，参数为一命令行模式进入该容器：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<p>-i：交互式操作。</p>
<p>-t：终端</p>
<p>ubuntu：ubuntu 镜像。</p>
<p>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</p>
<h3 id="启动已停止运行的容器"><a href="#启动已停止运行的容器" class="headerlink" title="启动已停止运行的容器"></a>启动已停止运行的容器</h3><ul>
<li>查看所有的容器命令如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/13/Docker%E6%A6%82%E5%BF%B5/3.png" alt="image-20200714104353774"></p>
<ul>
<li>使用 docker start 启动一个已停止的容器：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker start b750bbbcfd88</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/13/Docker%E6%A6%82%E5%BF%B5/4.png" alt="image-20200714104443037"></p>
<ul>
<li>后台运行，在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 <strong>-d</strong> 指定容器的运行模式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -itd --name ubuntu-test ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/13/Docker%E6%A6%82%E5%BF%B5/5.png" alt="image-20200714104607300"></p>
<ul>
<li>停止一个容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;容器 ID&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/13/Docker%E6%A6%82%E5%BF%B5/6.png" alt="image-20200714104701993"></p>
<ul>
<li>restart容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart &lt;容器 ID&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>进入容器</li>
</ul>
<p>在使用 <strong>-d</strong> 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p>
<p><strong>docker attach</strong></p>
<p><strong>docker exec</strong>：推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach 1e560fca3906</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 如果从这个容器退出，会导致容器的停止。</p>
<p><strong>docker exec</strong>：推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 243c32535da7 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 如果从这个容器退出，不会导致容器的停止，这就是为什么推荐大家使用 <strong>docker exec</strong> 的原因。</p>
<p>更多参数说明请使用 <strong>docker exec –help</strong> 命令查看。</p>
<ul>
<li>导出容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker export 1e560fca3906 &gt; ubuntu.tar</span><br></pre></td></tr></table></figure>
<p>导出容器 1e560fca3906 快照到本地文件 ubuntu.tar。</p>
<ul>
<li>导入容器快照</li>
</ul>
<p>可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat docker&#x2F;ubuntu.tar | docker import - test&#x2F;ubuntu:v1</span><br></pre></td></tr></table></figure>
<p>此外，也可以通过指定 URL 或者某个目录来导入，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo</span><br></pre></td></tr></table></figure>
<ul>
<li>删除容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f 1e560fca3906</span><br></pre></td></tr></table></figure>
<p>下面的命令可以清理掉所有处于终止状态的容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container prune</span><br></pre></td></tr></table></figure>
<h2 id="运行一个web应用"><a href="#运行一个web应用" class="headerlink" title="运行一个web应用"></a>运行一个web应用</h2><p>前面我们运行的容器并没有一些什么特别的用处。</p>
<p>接下来让我们尝试使用 docker 构建一个 web 应用程序。</p>
<p>我们将在docker容器中运行一个 Python Flask 应用来运行一个web应用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~# docker pull training&#x2F;webapp  # 载入镜像</span><br><span class="line">runoob@runoob:~# docker run -d -P training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure>
<ul>
<li>查看web 应用容器</li>
</ul>
<p>使用 docker ps 来查看我们正在运行的容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~#  docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             ...        PORTS                 </span><br><span class="line">d3d5e39ed9d3        training&#x2F;webapp     &quot;python app.py&quot;     ...        0.0.0.0:32769-&gt;5000&#x2F;tcp</span><br></pre></td></tr></table></figure>
<p>这里多了端口信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PORTS</span><br><span class="line">0.0.0.0:32769-&gt;5000&#x2F;tcp</span><br></pre></td></tr></table></figure>
<p>Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 32769 上。</p>
<p>这时我们可以通过浏览器访问WEB应用</p>
<p><img src="/2020/07/13/Docker%E6%A6%82%E5%BF%B5/7.png" alt="image-20200714105844095"></p>
<p>我们也可以通过 -p 参数来设置不一样的端口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -d -p 5000:5000 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure>
<ul>
<li>网络端口的快捷方式</li>
</ul>
<p>通过 <strong>docker ps</strong> 命令可以查看到容器的端口映射，<strong>docker</strong> 还提供了另一个快捷方式 <strong>docker port</strong>，使用 <strong>docker port</strong> 可以查看指定 （ID 或者名字）容器的某个确定端口映射到宿主机的端口号。</p>
<p>上面我们创建的 web 应用容器 ID 为 <strong>bf08b7f2cd89</strong> 名字为 <strong>wizardly_chandrasekhar</strong>。</p>
<p>我可以使用 <strong>docker port bf08b7f2cd89</strong> 或 <strong>docker port wizardly_chandrasekhar</strong> 来查看容器端口的映射情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker port bf08b7f2cd89</span><br><span class="line">5000&#x2F;tcp -&gt; 0.0.0.0:5000</span><br><span class="line">runoob@runoob:~$ docker port wizardly_chandrasekhar</span><br><span class="line">5000&#x2F;tcp -&gt; 0.0.0.0:5000</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>查看WEB应用程序日志</strong></li>
</ul>
<p>docker logs [ID或者名字] 可以查看容器内部的标准输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker logs -f bf08b7f2cd89</span><br><span class="line"> * Running on http:&#x2F;&#x2F;0.0.0.0:5000&#x2F; (Press CTRL+C to quit)</span><br><span class="line">192.168.239.1 - - [09&#x2F;May&#x2F;2016 16:30:37] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">192.168.239.1 - - [09&#x2F;May&#x2F;2016 16:30:37] &quot;GET &#x2F;favicon.ico HTTP&#x2F;1.1&quot; 404 -</span><br></pre></td></tr></table></figure>
<p><strong>-f:</strong> 让 <strong>docker logs</strong> 像使用 <strong>tail -f</strong> 一样来输出容器内部的标准输出。</p>
<p>从上面，我们可以看到应用程序使用的是 5000 端口并且能够查看到应用程序的访问日志。</p>
<ul>
<li>查看WEB应用程序容器的进程</li>
</ul>
<p>我们还可以使用 docker top 来查看容器内部运行的进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker top wizardly_chandrasekhar</span><br><span class="line">UID     PID         PPID          ...       TIME                CMD</span><br><span class="line">root    23245       23228         ...       00:00:00            python app.py</span><br></pre></td></tr></table></figure>
<ul>
<li>检查WEB应用程序</li>
</ul>
<p>使用<strong>docker inspect</strong> 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker inspect wizardly_chandrasekhar</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;bf08b7f2cd897b5964943134aa6d373e355c286db9b9885b1f60b6e8f82b2b85&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2018-09-17T01:41:26.174228707Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;python&quot;,</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;app.py&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;State&quot;: &#123;</span><br><span class="line">            &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">            &quot;Running&quot;: true,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Restarting&quot;: false,</span><br><span class="line">            &quot;OOMKilled&quot;: false,</span><br><span class="line">            &quot;Dead&quot;: false,</span><br><span class="line">            &quot;Pid&quot;: 23245,</span><br><span class="line">            &quot;ExitCode&quot;: 0,</span><br><span class="line">            &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">            &quot;StartedAt&quot;: &quot;2018-09-17T01:41:26.494185806Z&quot;,</span><br><span class="line">            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<ul>
<li>停止WEB应用容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker stop wizardly_chandrasekhar   </span><br><span class="line">wizardly_chandrasekhar</span><br></pre></td></tr></table></figure>
<ul>
<li>重启WEB应用容器</li>
</ul>
<p>已经停止的容器，我们可以使用命令 docker start 来启动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker start wizardly_chandrasekhar</span><br><span class="line">wizardly_chandrasekhar</span><br></pre></td></tr></table></figure>
<ul>
<li>docker ps -l 查询最后一次创建的容器：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#  docker ps -l </span><br><span class="line">CONTAINER ID        IMAGE                             PORTS                     NAMES</span><br><span class="line">bf08b7f2cd89        training&#x2F;webapp     ...        0.0.0.0:5000-&gt;5000&#x2F;tcp    wizardly_chandrasekhar</span><br></pre></td></tr></table></figure>
<ul>
<li>移除WEB应用容器</li>
</ul>
<p>我们可以使用 docker rm 命令来删除不需要的容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker rm wizardly_chandrasekhar  </span><br><span class="line">wizardly_chandrasekhar</span><br></pre></td></tr></table></figure>
<p>删除容器时，容器必须是停止状态，否则会报如下错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker rm wizardly_chandrasekhar</span><br><span class="line">Error response from daemon: You cannot remove a running container bf08b7f2cd897b5964943134aa6d373e355c286db9b9885b1f60b6e8f82b2b85. Stop the container before attempting removal or force remove</span><br></pre></td></tr></table></figure>
<h1 id="Docker镜像使用"><a href="#Docker镜像使用" class="headerlink" title="Docker镜像使用"></a>Docker镜像使用</h1><p>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</p>
<ul>
<li>列出镜像列表</li>
</ul>
<p>我们可以使用 <strong>docker images</strong> 来列出本地主机上的镜像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker images           </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04               90d5884b1ee0        5 days ago          188 MB</span><br><span class="line">php                 5.6                 f40e9e0f10c8        9 days ago          444.8 MB</span><br><span class="line">nginx               latest              6f8d099c3adc        12 days ago         182.7 MB</span><br><span class="line">mysql               5.6                 f2e8d6c772c0        3 weeks ago         324.6 MB</span><br><span class="line">httpd               latest              02ef73cf1bc0        3 weeks ago         194.4 MB</span><br><span class="line">ubuntu              15.10               4e3b13c8a266        4 weeks ago         136.3 MB</span><br><span class="line">hello-world         latest              690ed74de00f        6 months ago        960 B</span><br><span class="line">training&#x2F;webapp     latest              6fae60ef3446        11 months ago       348.8 MB</span><br></pre></td></tr></table></figure>
<p>各个选项说明:</p>
<p><strong>REPOSITORY：</strong>表示镜像的仓库源</p>
<p><strong>TAG：</strong>镜像的标签</p>
<p><strong>IMAGE ID：</strong>镜像ID</p>
<p><strong>CREATED：</strong>镜像创建时间</p>
<p><strong>SIZE：</strong>镜像大小</p>
<ul>
<li>获取一个新的镜像</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Crunoob@runoob:~$ docker pull ubuntu:13.10</span><br></pre></td></tr></table></figure>
<ul>
<li>查找镜像</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$  docker search httpd</span><br></pre></td></tr></table></figure>
<ul>
<li>使用镜像</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker run httpd</span><br></pre></td></tr></table></figure>
<ul>
<li>删除镜像</li>
</ul>
<p>镜像删除使用 <strong>docker rmi</strong> 命令，比如我们删除 hello-world 镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi hello-world</span><br></pre></td></tr></table></figure>
<h1 id="Docker-DockerFile"><a href="#Docker-DockerFile" class="headerlink" title="Docker DockerFile"></a>Docker DockerFile</h1><p><strong>什么是DockerFile？</strong></p>
<p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>
<p><strong>使用Dockerfile定制镜像</strong></p>
<p>1.下面以定制一个nginx镜像构建好的镜像内会有一个/usr/share/nginx/html/index.html文件</p>
<p>在一个空目录下，新建一个名为 Dockerfile 文件，并在文件内添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#39;这是一个本地构建的nginx镜像&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure>
<p><strong>2、FROM 和 RUN 指令的作用</strong></p>
<p><strong>FROM</strong>：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</p>
<p><strong>RUN</strong>：用于执行后面跟着的命令行命令。有以下俩种格式：</p>
<p><strong>注意</strong>：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install wget</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.3.tar.gz&quot;</span><br><span class="line">RUN tar -xvf redis.tar.gz</span><br><span class="line">以上执行会创建 3 层镜像。可简化为以下格式：</span><br><span class="line">FROM centos</span><br><span class="line">RUN yum install wget \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.3.tar.gz&quot; \</span><br><span class="line">    &amp;&amp; tar -xvf redis.tar.gz</span><br></pre></td></tr></table></figure>
<h1 id="开始构建镜像"><a href="#开始构建镜像" class="headerlink" title="开始构建镜像"></a>开始构建镜像</h1><p>在 Dockerfile 文件的存放目录下，执行构建动作。</p>
<p>以下示例，通过目录下的 Dockerfile 构建一个 nginx:test（镜像名称:镜像标签）。</p>
<p><strong>注</strong>：最后的 <strong>.</strong> 代表本次执行的上下文路径，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:test .</span><br></pre></td></tr></table></figure>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/11/dockerfile2.png" alt="img"></p>
<p>以上显示，说明已经构建成功。</p>
<h3 id="上下文路径"><a href="#上下文路径" class="headerlink" title="上下文路径"></a>上下文路径</h3><p>上一节中，有提到指令最后一个 <strong>.</strong> 是上下文路径，那么什么是上下文路径呢？</p>
<p>$ docker build -t nginx:test .</p>
<p>上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</p>
<h2 id="Dockerfile基本结构"><a href="#Dockerfile基本结构" class="headerlink" title="Dockerfile基本结构"></a>Dockerfile基本结构</h2><p>Dockerfile 由一行行命令语句组成，并且支持已 # 开头的注释行。</p>
<p>一般而言，Dockerfile 的内容分为四个部分：<br><strong>基础镜像信息</strong></p>
<p><strong>维护者信息</strong></p>
<p><strong>镜像操作指令</strong></p>
<p><strong>容器启动时执行指令</strong></p>
<p><strong>Dockerfile完整demo</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"># This dockerfile demo for project build to docker images</span><br><span class="line"># VERSION 2</span><br><span class="line"># Author: Shawn_xiao</span><br><span class="line"># Command format: Instruction [arguments &#x2F; command] …</span><br><span class="line"># 2018&#x2F;10&#x2F;10- firstversion: xiao</span><br><span class="line"># 2018&#x2F;10&#x2F;11- chanege the tomcat version</span><br><span class="line"></span><br><span class="line"># 第一行必须指定基础容器，建议使用aipln类型的小容器</span><br><span class="line">FROM tomcat:8</span><br><span class="line"></span><br><span class="line"># 维护者信息(可选)</span><br><span class="line">MAINTAINER xiaojianjun xiaojianjun@tansun.com.cn</span><br><span class="line"></span><br><span class="line"># LABEL (可选) 标签信息(自定义信息,多标签放一行)</span><br><span class="line">LABEL app.maintainer&#x3D;xiaojianjun</span><br><span class="line">LABEL app.version&#x3D;&quot;1.0&quot; app.host&#x3D;&#39;bestxiao.cn&#39; description&#x3D;&quot;这个app产品构建&quot;</span><br><span class="line"></span><br><span class="line"># ENV  (可选)环境变量(指定一个环境变量，会被后续 RUN 指令使用，并在容器运行时保持 </span><br><span class="line">ENV JAVA_HOME &#x2F;opt&#x2F;java_jdk&#x2F;bin</span><br><span class="line">ENV PG_VERSION 9.3.4</span><br><span class="line">ENV PATH &#x2F;usr&#x2F;local&#x2F;postgres-$PG_MAJOR&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line"># USER (可选) 指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户,前面的RUN 不受影响</span><br><span class="line"># RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres </span><br><span class="line">USER postgres</span><br><span class="line"></span><br><span class="line"># WORKDIT 后续的 RUN、CMD、ENTRYPOINT 指令配置容器内的工作目录</span><br><span class="line">WORKDIR &#x2F;path&#x2F;to&#x2F;workdir</span><br><span class="line"></span><br><span class="line"># ADD&#x2F;COPY 将外部文件copy到容器中。区别是ADD可以使用URL，还可以是tar</span><br><span class="line"># COPY只能使用dockerfile所在目录</span><br><span class="line"># ADD &lt;src&gt; &lt;dest&gt;</span><br><span class="line"># COPY &lt;src&gt; &lt;dest&gt;</span><br><span class="line">COPY target&#x2F;tomcat-release.war &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;</span><br><span class="line"></span><br><span class="line"># RUN 镜像的操作指令</span><br><span class="line"># RUN &lt;command&gt; [“executable”, “param1”, “param2”]。</span><br><span class="line">RUN echo “deb http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu&#x2F; raring main universe” &gt;&gt; &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y nginx</span><br><span class="line">RUN mkdir &#x2F;opt&#x2F;deploy&#x2F;</span><br><span class="line">RUN echo “\ndaemon off;” &gt;&gt; &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line"></span><br><span class="line"># EXPOSE 容器启动后需要暴露的端口</span><br><span class="line">EXPOSE 22 80 8443 8080</span><br><span class="line"></span><br><span class="line"># VOLUME 本地或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</span><br><span class="line">#VOLUME [&quot;&#x2F;data&quot;]</span><br><span class="line">VOLUME [&quot;&#x2F;data&#x2F;postgres&quot;, &quot;&#x2F;other&#x2F;path&#x2F;&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ENTRYPOINT  容器启动后执行命令，不会被docker run提供的参数覆盖，只能有一个ENTRYPOINT,</span><br><span class="line"># 多个ENTRYPOINT，以最后一个为准</span><br><span class="line">#ENTRYPOINT [“executable”, “param1”, “param2”]</span><br><span class="line">#ENTRYPOINT command param param2</span><br><span class="line">ENTRYPOINT echo &quot;helloDocker&quot;  </span><br><span class="line"></span><br><span class="line"># 容器启动时执行指令,每个 Dockerfile 只能有一条 CMD 命令</span><br><span class="line">#CMD [“executable”, “param1”, “param2”] 使用 exec 执行，推荐方式。</span><br><span class="line">#CMD command param1 param2 在 &#x2F;bin&#x2F;sh 中执行，提供给需要交互的应用。</span><br><span class="line">#CMD [“param1”, “param2”] 提供给 ENTRYPOINT 的默认参数。</span><br><span class="line">CMD &#x2F;usr&#x2F;sbin&#x2F;nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ONBUILD 配置当所创建的镜像作为其他新创建镜像的基础镜像时，所执行的操作指令。例如，Dockerfile 使用如下的内容创建了镜像 image-A。-- 很少使用</span><br><span class="line"></span><br><span class="line"># ONBUILD ADD . &#x2F;app&#x2F;src</span><br><span class="line"># ONBUILD RUN &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python-build –dir &#x2F;app&#x2F;src</span><br></pre></td></tr></table></figure>
<p><strong>简短demo</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">LABEL version&#x3D;&quot;1.0&quot; description&#x3D;&quot;centos7&quot; by&#x3D;&quot;测试&quot;</span><br><span class="line">ENV MYPATH &#x2F;usr&#x2F;local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install java-1.8.0-openjdk </span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo &quot;------success------OK------&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#指定镜像</span><br><span class="line">FROM primetoninc&#x2F;jdk:1.8</span><br><span class="line">#拷贝宿主机的app.jar</span><br><span class="line">COPY app.jar app.jar</span><br><span class="line">#配置端口</span><br><span class="line">EXPOSE 8080</span><br><span class="line">#运行app.jar包</span><br><span class="line">ENTRYPOINT exec java -jar app.jar</span><br></pre></td></tr></table></figure>
<h2 id="DockerFile关键指令"><a href="#DockerFile关键指令" class="headerlink" title="DockerFile关键指令"></a>DockerFile关键指令</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a><strong>FROM</strong></h3><p>格式为 FROM <image> 或 FROM<image>:<tag>。<br>Dockerfile 的第一条指令必须为 FROM 指令。并且，如果在同一个 Dockerfile 中创建多个镜像时，可以使用多个 FROM 指令。</tag></image></image></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 第一行必须指定基础容器，这里的是tomcat8</span><br><span class="line">FROM tomcat:8</span><br></pre></td></tr></table></figure>
<h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a><strong>MAINTAINER</strong></h3><p>格式为 MAINTAINER <name>，指定维护者信息。</name></p>
<p>注意：MAINTAINER 指令已经被抛弃，建议使用 LABEL 指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 维护者信息(可选)建议用LABEL 指令</span><br><span class="line">MAINTAINER xiaojianjun xiaojianjun@tansun.com.cn</span><br></pre></td></tr></table></figure>
<h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a><strong>LABEL</strong></h3><p>LABEL 指令为镜像添加标签。一个 LABEL 就是一个键值对，也可以一行指定多个键值对。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#多行指定信息</span><br><span class="line">LABEL com.example.label-with-value&#x3D;&quot;foo&quot;</span><br><span class="line">LABEL version&#x3D;&quot;1.0&quot;</span><br><span class="line">LABEL description&#x3D;&quot;This text illustrates \that label-values can span multiple lines.&quot;</span><br><span class="line"></span><br><span class="line">#一行指定多个键值对</span><br><span class="line">LABEL app.version&#x3D;&quot;1.0&quot; app.host&#x3D;&#39;bestxiao.cn&#39; description&#x3D;&quot;这个app产品构建&quot;</span><br></pre></td></tr></table></figure>
<p><strong>如果新添加的 LABEL 和已有的 LABEL 同名，则新值会覆盖掉旧值。</strong></p>
<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a><strong>RUN</strong></h3><p>每条 RUN 指令将在当前镜像的基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用 \ 来换行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN yum -y install java-1.8.0-openjdk</span><br></pre></td></tr></table></figure>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a><strong>CMD</strong></h3><p>指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条 CMD 命令，只有最后一条会被执行。如果用户在启动容器时指定了要运行的命令，则会覆盖掉 CMD 指定的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD echo &quot;------success------OK------&quot;</span><br></pre></td></tr></table></figure>
<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a><strong>EXPOSE</strong></h3><p>告诉 Docker 服务，容器需要暴露的端口号，供互联系统使用。在启动容器时需要通过 -P 参数让 Docker 主机分配一个端口转发到指定的端口。使用 -p 参数则可以具体指定主机上哪个端口映射过来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 22 80 8443 8080</span><br></pre></td></tr></table></figure>
<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a><strong>ENV</strong></h3><p>格式为 ENV <key> <value>。指定一个环境变量，会被后续 RUN 指令使用，并在容器运行时保持。</value></key></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENV PG_MAJOR 9.3</span><br><span class="line">ENV PG_VERSION 9.3.4</span><br><span class="line">RUN curl -SL http:&#x2F;&#x2F;example.com&#x2F;postgres-$PG_VERSION.tar.xz | tar -xJC &#x2F;usr&#x2F;src&#x2F;postgress &amp;&amp; …</span><br><span class="line">ENV PATH &#x2F;usr&#x2F;local&#x2F;postgres-$PG_MAJOR&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>
<h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a><strong>ADD</strong></h3><p>该命令将复制指定的 <src> 到容器中的 <dest>。其中 <src> 可以是 Dockerfile 所在目录的一个相对路径(文件或目录)；也可以是一个 URL；还可以是一个 tar 文件(自动解压为目录)。</src></dest></src></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt; &lt;dest&gt;</span><br></pre></td></tr></table></figure>
<h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a><strong>COPY</strong></h3><p>复制本地主机的 <src> (为 Dockerfile 所在目录的相对路径，文件或目录) 为容器中的 <dest>。目标路径不存在时，会自动创建。当使用本地目录为源目录时，推荐使用 COPY。</dest></src></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;src&gt; &lt;dest&gt;</span><br></pre></td></tr></table></figure>
<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a><strong>ENTRYPOINT</strong></h3><p>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。<br>每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个 ENTRYPOINT 时，只有最后一个生效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [“executable”, “param1”, “param2”]</span><br><span class="line">ENTRYPOINT command param1 param2 (shell 中执行)</span><br></pre></td></tr></table></figure>
<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a><strong>VOLUME</strong></h3><p>使用 VOLUME 指令添加多个数据卷，创建一个可以从本地或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;&#x2F;data&quot;]</span><br><span class="line">VOLUME [&quot;&#x2F;data1&quot;, &quot;&#x2F;data2&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a><strong>USER</strong></h3><p>指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">USER daemon</span><br><span class="line">或</span><br><span class="line">RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</span><br></pre></td></tr></table></figure>
<h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a><strong>WORKDIR</strong></h3><p>为后续的 RUN、CMD、ENTRYPOINT 指令配置工作目录。可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># WORKDIT 后续的 RUN、CMD、ENTRYPOINT 指令配置容器内的工作目录</span><br><span class="line">WORKDIR &#x2F;path&#x2F;to&#x2F;workdir</span><br></pre></td></tr></table></figure>
<h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a><strong>ONBUILD</strong></h3><p>配置当所创建的镜像作为其他新创建镜像的基础镜像时，所执行的操作指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM image-A#automatically run the followingADD ONBUILD ADD . &#x2F;app&#x2F;srcONBUILD RUN &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python-build –dir &#x2F;app&#x2F;src</span><br></pre></td></tr></table></figure>
<p>如果基于 image-A 创建新的镜像时，新的 Dockerfile 中使用 FROM image-A 指定基础镜像时，会自动执行 ONBUILD 指令内容，等价于在后面添加了两条指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM image-A#automatically run the followingADD . &#x2F;app&#x2F;srcRUN &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python-build –dir &#x2F;app&#x2F;src</span><br></pre></td></tr></table></figure>

      
    </div>
    
  </div>
  
    
         



<nav id="article-nav">
  
    <a  href="/2020/07/26/SpringBoot-Hello-World/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          SpringBoot Hello World
        
      </div>
    </a>
  
  
    <a  href="/2020/07/12/Hive-%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%92%8C%E5%8E%9F%E7%90%86/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Hive 索引机制和原理</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>


  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为什么需要Docker？"><span class="toc-number">2.</span> <span class="toc-text">为什么需要Docker？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-环境（切换-配置）麻烦"><span class="toc-number">2.1.</span> <span class="toc-text">1.环境（切换&#x2F;配置）麻烦</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-应用之间需要隔离"><span class="toc-number">2.2.</span> <span class="toc-text">2.应用之间需要隔离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker是如何解决上述的问题"><span class="toc-number">2.3.</span> <span class="toc-text">Docker是如何解决上述的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-解决环境-切换-配置"><span class="toc-number">2.4.</span> <span class="toc-text">1.解决环境(切换&#x2F;配置)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-解决应用之间隔离"><span class="toc-number">2.5.</span> <span class="toc-text">2.解决应用之间隔离</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#虚拟机和Docker"><span class="toc-number">3.</span> <span class="toc-text">虚拟机和Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机和Docker的区别"><span class="toc-number">3.1.</span> <span class="toc-text">虚拟机和Docker的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-基本命令"><span class="toc-number">4.</span> <span class="toc-text">Docker 基本命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hello-world"><span class="toc-number">4.1.</span> <span class="toc-text">Hello world</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行交互式的容器"><span class="toc-number">4.2.</span> <span class="toc-text">运行交互式的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#启动容器后台模式"><span class="toc-number">4.3.</span> <span class="toc-text">启动容器后台模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker容器使用"><span class="toc-number">4.4.</span> <span class="toc-text">Docker容器使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#启动已停止运行的容器"><span class="toc-number">4.4.1.</span> <span class="toc-text">启动已停止运行的容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行一个web应用"><span class="toc-number">4.5.</span> <span class="toc-text">运行一个web应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker镜像使用"><span class="toc-number">5.</span> <span class="toc-text">Docker镜像使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-DockerFile"><span class="toc-number">6.</span> <span class="toc-text">Docker DockerFile</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#开始构建镜像"><span class="toc-number">7.</span> <span class="toc-text">开始构建镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#上下文路径"><span class="toc-number">7.0.1.</span> <span class="toc-text">上下文路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dockerfile基本结构"><span class="toc-number">7.1.</span> <span class="toc-text">Dockerfile基本结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DockerFile关键指令"><span class="toc-number">7.2.</span> <span class="toc-text">DockerFile关键指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FROM"><span class="toc-number">7.2.1.</span> <span class="toc-text">FROM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MAINTAINER"><span class="toc-number">7.2.2.</span> <span class="toc-text">MAINTAINER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LABEL"><span class="toc-number">7.2.3.</span> <span class="toc-text">LABEL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RUN"><span class="toc-number">7.2.4.</span> <span class="toc-text">RUN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMD"><span class="toc-number">7.2.5.</span> <span class="toc-text">CMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXPOSE"><span class="toc-number">7.2.6.</span> <span class="toc-text">EXPOSE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ENV"><span class="toc-number">7.2.7.</span> <span class="toc-text">ENV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ADD"><span class="toc-number">7.2.8.</span> <span class="toc-text">ADD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#COPY"><span class="toc-number">7.2.9.</span> <span class="toc-text">COPY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ENTRYPOINT"><span class="toc-number">7.2.10.</span> <span class="toc-text">ENTRYPOINT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VOLUME"><span class="toc-number">7.2.11.</span> <span class="toc-text">VOLUME</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USER"><span class="toc-number">7.2.12.</span> <span class="toc-text">USER</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WORKDIR"><span class="toc-number">7.2.13.</span> <span class="toc-text">WORKDIR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ONBUILD"><span class="toc-number">7.2.14.</span> <span class="toc-text">ONBUILD</span></a></li></ol></li></ol></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";
    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>






    
        <section class="changyan" id="comments">
  <!--<div id="uyan_frame"></div>-->
  <div id="SOHUCS"></div>
  <script charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/changyan.js"></script>
  <script type="text/javascript">
    window.changyan.api.config({
      appid: 'xxxx',
      conf: 'xxxxxxxxx'
    });
  </script>
</section>
    



    <div class="scroll" id="post-nav-button">
        
            <a  href="/2020/07/26/SpringBoot-Hello-World/" title="上一篇: SpringBoot Hello World">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a  href="/2020/07/12/Hive-%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%92%8C%E5%8E%9F%E7%90%86/" title="下一篇: Hive 索引机制和原理">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/08/01/MinIO%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/">MinIO分布式对象存储服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/26/Git/">Git</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/26/SpringBoot-Hello-World/">SpringBoot Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/13/Docker%E6%A6%82%E5%BF%B5/">Docker概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/12/Hive-%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%92%8C%E5%8E%9F%E7%90%86/">Hive 索引机制和原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/10/Hive%E5%B8%B8%E7%94%A8DDL%E6%93%8D%E4%BD%9C/">Hive常用DDL操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/08/Hive/">Hive</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/03/Kafka-Eagle/">Kafka Eagle</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/30/Kafka-producer/">Kafka producer</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/21/Flink-DataStream-API%E7%BC%96%E7%A8%8B/">Flink DataStream API编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/21/Flink-Table-API-SQL%E7%BC%96%E7%A8%8B/">Flink Table API&SQL编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/27/Scala/">Scala</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/06/Flume%E7%9B%91%E6%8E%A7%E4%B9%8BGanglia/">Flume监控之Ganglia</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/02/HDFS-NameNode%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6/">HDFS NameNode的工作机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/28/Java%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81/">Java线程死锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/21/Zeppelin-%E5%AE%89%E8%A3%85/">Zeppelin 安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/09/Kafka%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%90%9E%E5%90%90%E4%B9%8B%E9%9B%B6%E6%8B%B7%E8%B4%9D/">Kafka实现高吞吐之零拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/">Java虚拟机运行时数据区域</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/VMwareWorkstation-pro%E6%97%A0%E6%B3%95%E5%9C%A8Windows%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98/">VMwareWorkstation pro无法在Windows上运行的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/17/Zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/">Zookeeper分布式集群部署</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/10/VisualVM-%E5%A4%9A%E5%90%88%E4%B8%80%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/">VisualVM:多合一故障处理工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/09/JConsole-Java%E7%9B%91%E8%A7%86%E4%B8%8E%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0/">JConsole:Java监视与管理控制台</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/08/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">垃圾收集器</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/07/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/">HotSpot虚拟机对象探秘</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/">垃圾收集算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%AD%BB%E4%BA%A1/">如何判断对象是否死亡?</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/29/Spark-Demo-Serializable/">Spark Demo(Serializable)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/16/Spark-%E6%A6%82%E8%BF%B0/">Spark 概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/16/Spark-Error/">Spark Error</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/15/Spark%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/">Spark压缩文件性能分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/13/Apache-Flink-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%8E%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6/">Apache Flink 状态管理与容错机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/10/Apache-Spark%E7%AE%80%E5%8D%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/">Apache Spark简单构建一个应用程序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/10/Apache-Flink-%E7%AE%80%E5%8D%95%E7%9A%84%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/">Apache Flink 简单的构建一个应用程序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/08/Apache-Flink-DataStream-API-%E7%BC%96%E7%A8%8B/">Apache Flink DataStream API 编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/05/Apache-Flink%E6%A6%82%E5%BF%B5/">Apache Flink概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/02/Zeppelin/">Zeppelin</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/20/Kafka-%E6%A6%82%E8%BF%B0/">Kafka 概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/08/HDFS-1-0-%E4%B8%8E-2-0/">HDFS(1.0)与(2.0)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/03/Hadoop%E5%AE%89%E8%A3%85/">Hadoop安装</a></li></ul>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

    <script>
        $(".post-list").addClass("toc-article");
        // $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2020 落墨
            </div>
         
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >极客到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>


<script src="/js/main.js"></script>


    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'xxxxx', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?xxxxxx";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>



<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>