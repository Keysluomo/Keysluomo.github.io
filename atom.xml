<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>落墨</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://keysluomo.github.io/"/>
  <updated>2020-06-04T10:05:29.965Z</updated>
  <id>https://keysluomo.github.io/</id>
  
  <author>
    <name>落墨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java线程死锁</title>
    <link href="https://keysluomo.github.io/2020/06/04/Java%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81/"/>
    <id>https://keysluomo.github.io/2020/06/04/Java线程死锁/</id>
    <published>2020-06-04T10:03:02.000Z</published>
    <updated>2020-06-04T10:05:29.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java线程死锁"><a href="#Java线程死锁" class="headerlink" title="Java线程死锁"></a>Java线程死锁</h1><blockquote><br>死锁是一种特定的程序状态，在实体之间，由于循环依赖导致彼此一直处于等待之中，没有 任何个体可以继续前进。死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也 可能出现死锁。通常来说，我们大多是聚焦在多线程场景中的死锁，指两个或多个线程之 间，由于互相持有对方需要的锁，而永久处于阻塞的状态。<br><br></blockquote><p><strong>Java线程死锁</strong>是一个经典的多线程问题，因为不同的线程都在等待那些根本不可能被释放的锁，从而导致所有的工作都无法完成。如图所示</p><p><img src="https://uploadfiles.nowcoder.com/images/20200328/9094293_1585401927118_07B48ACC39A047AFA2370A7A0A6DA87D" alt="图片说明" title="图片标题"></p><hr><h2 id="如何去定位Java线程死锁呢？"><a href="#如何去定位Java线程死锁呢？" class="headerlink" title="如何去定位Java线程死锁呢？"></a>如何去定位Java线程死锁呢？</h2><p>定位死锁最常见的方式就是利用 jstack 等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。如果是比较明显的死锁，往往 jstack 等就能直接定位，类似 JConsole 甚至可以在图形界面进行有限的死锁检测。<br>既然了解了用什么工具去定位线程死锁，那我们模拟一个Java线程死锁的情况，实战定位线程死锁<br><strong>死锁代码：</strong></p><pre><code>/** * @Author:luomo * @CreateTime: 2020/3/28 * @Description:模拟DeadLock */public class deadLock implements Runnable{    public static  Object obj1=new Object();    public static  Object obj2=new Object();    private int flag;    deadLock(int flag){        this.flag=flag;    }    @Override    public void run() {        if(flag==0){            synchronized (obj1){                System.out.println(Thread.currentThread().getName()+&quot;成功获取锁1&quot;);                try {                    Thread.currentThread().sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(Thread.currentThread().getName()+&quot;尝试获取锁2&quot;);                synchronized (obj2){                    System.out.println(Thread.currentThread().getName()+&quot;成功获取锁2&quot;);                }            }        }else{            synchronized (obj2){                System.out.println(Thread.currentThread().getName()+&quot;成功获取锁2&quot;);                try {                    Thread.currentThread().sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(Thread.currentThread().getName()+&quot;尝试获取锁1&quot;);                synchronized (obj1){                    System.out.println(Thread.currentThread().getName()+&quot;成功获取锁2&quot;);                }            }        }    }    public static void main(String[] args) {   deadLock d1=new deadLock(0);   deadLock d2=new deadLock(1);   Thread thread1=new Thread(d1);   Thread thread2=new Thread(d2);   thread1.start();   thread2.start();    }}</code></pre><p><strong>代码运行：</strong></p><p><img src="https://uploadfiles.nowcoder.com/images/20200328/9094293_1585403107690_658136C48B9F238591D2641B71158055" alt=" " title="图片标题"></p><p>从运行结果我们看到Thread1和Thread0同时都在争用对方已经占有的锁，进而产生死锁。</p><hr><h2 id="如何定位死锁"><a href="#如何定位死锁" class="headerlink" title="如何定位死锁"></a>如何定位死锁</h2><p>如果程序发生了死锁，我们如何去定位死锁？我们可以通过JConsole工具来发现死锁。<br>打开cmd：输入 JConsole 回车<br>我们可以看到一个可视化的工具，找到死锁进程点击连接</p><p><img src="https://uploadfiles.nowcoder.com/images/20200328/9094293_1585404404899_8557B51B43F176BE982E6106A235FF71" alt="图片说明" title="图片标题"></p><p>我们可以看到有检查死锁的选项</p><p><img src="https://uploadfiles.nowcoder.com/images/20200328/9094293_1585404990224_C86CBC71C8D021A9183BF2C3CDF76F0A" alt="图片说明" title="图片标题"></p><p><img src="https://uploadfiles.nowcoder.com/images/20200328/9094293_1585405041821_D19472298BE0A95DE8CC6B0F8EEC456C" alt="图片说明" title="图片标题"></p><p><img src="https://uploadfiles.nowcoder.com/images/20200328/9094293_1585405052372_3C3A43AE4AAE4E7FB46EFEA38BB55A58" alt="图片说明" title="图片标题"></p><p>通过上图我们可以发现产生死锁的线程，从而定位到发生死锁的代码。</p><p>当然我们还可以使用Jstack + pid的方式来定位问题</p><p><img src="https://uploadfiles.nowcoder.com/images/20200328/9094293_1585405207484_62880453E402CF1B517F8064E6E18A93" alt="图片说明" title="图片标题"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java线程死锁&quot;&gt;&lt;a href=&quot;#Java线程死锁&quot; class=&quot;headerlink&quot; title=&quot;Java线程死锁&quot;&gt;&lt;/a&gt;Java线程死锁&lt;/h1&gt;&lt;blockquote&gt;&lt;br&gt;死锁是一种特定的程序状态，在实体之间，由于循环依赖导致彼此一直处于
      
    
    </summary>
    
      <category term="Java" scheme="https://keysluomo.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>secondblog</title>
    <link href="https://keysluomo.github.io/2020/06/04/secondblog/"/>
    <id>https://keysluomo.github.io/2020/06/04/secondblog/</id>
    <published>2020-06-03T17:33:39.000Z</published>
    <updated>2020-06-04T06:44:16.507Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java" scheme="https://keysluomo.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>firstBlog</title>
    <link href="https://keysluomo.github.io/2020/06/03/firstBlog/"/>
    <id>https://keysluomo.github.io/2020/06/03/firstBlog/</id>
    <published>2020-06-02T18:41:04.000Z</published>
    <updated>2020-06-04T06:43:35.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Flink" scheme="https://keysluomo.github.io/categories/Flink/"/>
    
    
  </entry>
  
</feed>
